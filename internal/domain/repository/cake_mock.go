// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package repository

import (
	"github.com/gin-gonic/gin"
	"privy-backend-test/internal/domain"
	"sync"
)

// Ensure, that CakeRepositoryMock does implement CakeRepository.
// If this is not the case, regenerate this file with moq.
var _ CakeRepository = &CakeRepositoryMock{}

// CakeRepositoryMock is a mock implementation of CakeRepository.
//
//	func TestSomethingThatUsesCakeRepository(t *testing.T) {
//
//		// make and configure a mocked CakeRepository
//		mockedCakeRepository := &CakeRepositoryMock{
//			DeleteFunc: func(ctx *gin.Context, id int64) error {
//				panic("mock out the Delete method")
//			},
//			GetCakeByIDFunc: func(ctx *gin.Context, id int64) (*domain.Cake, error) {
//				panic("mock out the GetCakeByID method")
//			},
//			GetCakesFunc: func(ctx *gin.Context) (*[]domain.Cake, error) {
//				panic("mock out the GetCakes method")
//			},
//			StoreFunc: func(ctx *gin.Context, cake *domain.Cake) error {
//				panic("mock out the Store method")
//			},
//			UpdateFunc: func(ctx *gin.Context, cake *domain.Cake) error {
//				panic("mock out the Update method")
//			},
//			UploadImageFunc: func(ctx *gin.Context, path string) error {
//				panic("mock out the UploadImage method")
//			},
//		}
//
//		// use mockedCakeRepository in code that requires CakeRepository
//		// and then make assertions.
//
//	}
type CakeRepositoryMock struct {
	// DeleteFunc mocks the Delete method.
	DeleteFunc func(ctx *gin.Context, id int64) error

	// GetCakeByIDFunc mocks the GetCakeByID method.
	GetCakeByIDFunc func(ctx *gin.Context, id int64) (*domain.Cake, error)

	// GetCakesFunc mocks the GetCakes method.
	GetCakesFunc func(ctx *gin.Context) (*[]domain.Cake, error)

	// StoreFunc mocks the Store method.
	StoreFunc func(ctx *gin.Context, cake *domain.Cake) error

	// UpdateFunc mocks the Update method.
	UpdateFunc func(ctx *gin.Context, cake *domain.Cake) error

	// UploadImageFunc mocks the UploadImage method.
	UploadImageFunc func(ctx *gin.Context, path string) error

	// calls tracks calls to the methods.
	calls struct {
		// Delete holds details about calls to the Delete method.
		Delete []struct {
			// Ctx is the ctx argument value.
			Ctx *gin.Context
			// ID is the id argument value.
			ID int64
		}
		// GetCakeByID holds details about calls to the GetCakeByID method.
		GetCakeByID []struct {
			// Ctx is the ctx argument value.
			Ctx *gin.Context
			// ID is the id argument value.
			ID int64
		}
		// GetCakes holds details about calls to the GetCakes method.
		GetCakes []struct {
			// Ctx is the ctx argument value.
			Ctx *gin.Context
		}
		// Store holds details about calls to the Store method.
		Store []struct {
			// Ctx is the ctx argument value.
			Ctx *gin.Context
			// Cake is the cake argument value.
			Cake *domain.Cake
		}
		// Update holds details about calls to the Update method.
		Update []struct {
			// Ctx is the ctx argument value.
			Ctx *gin.Context
			// Cake is the cake argument value.
			Cake *domain.Cake
		}
		// UploadImage holds details about calls to the UploadImage method.
		UploadImage []struct {
			// Ctx is the ctx argument value.
			Ctx *gin.Context
			// Path is the path argument value.
			Path string
		}
	}
	lockDelete      sync.RWMutex
	lockGetCakeByID sync.RWMutex
	lockGetCakes    sync.RWMutex
	lockStore       sync.RWMutex
	lockUpdate      sync.RWMutex
	lockUploadImage sync.RWMutex
}

// Delete calls DeleteFunc.
func (mock *CakeRepositoryMock) Delete(ctx *gin.Context, id int64) error {
	if mock.DeleteFunc == nil {
		panic("CakeRepositoryMock.DeleteFunc: method is nil but CakeRepository.Delete was just called")
	}
	callInfo := struct {
		Ctx *gin.Context
		ID  int64
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockDelete.Lock()
	mock.calls.Delete = append(mock.calls.Delete, callInfo)
	mock.lockDelete.Unlock()
	return mock.DeleteFunc(ctx, id)
}

// DeleteCalls gets all the calls that were made to Delete.
// Check the length with:
//
//	len(mockedCakeRepository.DeleteCalls())
func (mock *CakeRepositoryMock) DeleteCalls() []struct {
	Ctx *gin.Context
	ID  int64
} {
	var calls []struct {
		Ctx *gin.Context
		ID  int64
	}
	mock.lockDelete.RLock()
	calls = mock.calls.Delete
	mock.lockDelete.RUnlock()
	return calls
}

// GetCakeByID calls GetCakeByIDFunc.
func (mock *CakeRepositoryMock) GetCakeByID(ctx *gin.Context, id int64) (*domain.Cake, error) {
	if mock.GetCakeByIDFunc == nil {
		panic("CakeRepositoryMock.GetCakeByIDFunc: method is nil but CakeRepository.GetCakeByID was just called")
	}
	callInfo := struct {
		Ctx *gin.Context
		ID  int64
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockGetCakeByID.Lock()
	mock.calls.GetCakeByID = append(mock.calls.GetCakeByID, callInfo)
	mock.lockGetCakeByID.Unlock()
	return mock.GetCakeByIDFunc(ctx, id)
}

// GetCakeByIDCalls gets all the calls that were made to GetCakeByID.
// Check the length with:
//
//	len(mockedCakeRepository.GetCakeByIDCalls())
func (mock *CakeRepositoryMock) GetCakeByIDCalls() []struct {
	Ctx *gin.Context
	ID  int64
} {
	var calls []struct {
		Ctx *gin.Context
		ID  int64
	}
	mock.lockGetCakeByID.RLock()
	calls = mock.calls.GetCakeByID
	mock.lockGetCakeByID.RUnlock()
	return calls
}

// GetCakes calls GetCakesFunc.
func (mock *CakeRepositoryMock) GetCakes(ctx *gin.Context) (*[]domain.Cake, error) {
	if mock.GetCakesFunc == nil {
		panic("CakeRepositoryMock.GetCakesFunc: method is nil but CakeRepository.GetCakes was just called")
	}
	callInfo := struct {
		Ctx *gin.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetCakes.Lock()
	mock.calls.GetCakes = append(mock.calls.GetCakes, callInfo)
	mock.lockGetCakes.Unlock()
	return mock.GetCakesFunc(ctx)
}

// GetCakesCalls gets all the calls that were made to GetCakes.
// Check the length with:
//
//	len(mockedCakeRepository.GetCakesCalls())
func (mock *CakeRepositoryMock) GetCakesCalls() []struct {
	Ctx *gin.Context
} {
	var calls []struct {
		Ctx *gin.Context
	}
	mock.lockGetCakes.RLock()
	calls = mock.calls.GetCakes
	mock.lockGetCakes.RUnlock()
	return calls
}

// Store calls StoreFunc.
func (mock *CakeRepositoryMock) Store(ctx *gin.Context, cake *domain.Cake) error {
	if mock.StoreFunc == nil {
		panic("CakeRepositoryMock.StoreFunc: method is nil but CakeRepository.Store was just called")
	}
	callInfo := struct {
		Ctx  *gin.Context
		Cake *domain.Cake
	}{
		Ctx:  ctx,
		Cake: cake,
	}
	mock.lockStore.Lock()
	mock.calls.Store = append(mock.calls.Store, callInfo)
	mock.lockStore.Unlock()
	return mock.StoreFunc(ctx, cake)
}

// StoreCalls gets all the calls that were made to Store.
// Check the length with:
//
//	len(mockedCakeRepository.StoreCalls())
func (mock *CakeRepositoryMock) StoreCalls() []struct {
	Ctx  *gin.Context
	Cake *domain.Cake
} {
	var calls []struct {
		Ctx  *gin.Context
		Cake *domain.Cake
	}
	mock.lockStore.RLock()
	calls = mock.calls.Store
	mock.lockStore.RUnlock()
	return calls
}

// Update calls UpdateFunc.
func (mock *CakeRepositoryMock) Update(ctx *gin.Context, cake *domain.Cake) error {
	if mock.UpdateFunc == nil {
		panic("CakeRepositoryMock.UpdateFunc: method is nil but CakeRepository.Update was just called")
	}
	callInfo := struct {
		Ctx  *gin.Context
		Cake *domain.Cake
	}{
		Ctx:  ctx,
		Cake: cake,
	}
	mock.lockUpdate.Lock()
	mock.calls.Update = append(mock.calls.Update, callInfo)
	mock.lockUpdate.Unlock()
	return mock.UpdateFunc(ctx, cake)
}

// UpdateCalls gets all the calls that were made to Update.
// Check the length with:
//
//	len(mockedCakeRepository.UpdateCalls())
func (mock *CakeRepositoryMock) UpdateCalls() []struct {
	Ctx  *gin.Context
	Cake *domain.Cake
} {
	var calls []struct {
		Ctx  *gin.Context
		Cake *domain.Cake
	}
	mock.lockUpdate.RLock()
	calls = mock.calls.Update
	mock.lockUpdate.RUnlock()
	return calls
}

// UploadImage calls UploadImageFunc.
func (mock *CakeRepositoryMock) UploadImage(ctx *gin.Context, path string) error {
	if mock.UploadImageFunc == nil {
		panic("CakeRepositoryMock.UploadImageFunc: method is nil but CakeRepository.UploadImage was just called")
	}
	callInfo := struct {
		Ctx  *gin.Context
		Path string
	}{
		Ctx:  ctx,
		Path: path,
	}
	mock.lockUploadImage.Lock()
	mock.calls.UploadImage = append(mock.calls.UploadImage, callInfo)
	mock.lockUploadImage.Unlock()
	return mock.UploadImageFunc(ctx, path)
}

// UploadImageCalls gets all the calls that were made to UploadImage.
// Check the length with:
//
//	len(mockedCakeRepository.UploadImageCalls())
func (mock *CakeRepositoryMock) UploadImageCalls() []struct {
	Ctx  *gin.Context
	Path string
} {
	var calls []struct {
		Ctx  *gin.Context
		Path string
	}
	mock.lockUploadImage.RLock()
	calls = mock.calls.UploadImage
	mock.lockUploadImage.RUnlock()
	return calls
}
